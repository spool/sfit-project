class Grid
{
  int size;
  int divisions;
  Edge edges_h[][];
  Edge edges_v[][];
  Edge edges_d_se[][];
  Edge edges_d_sw[][];
  
  Grid(int size, int divisions)
  {
    this.size = size;
    this.divisions = divisions;
    this.edges_h = new Edge[size][size + 1];
    this.edges_v = new Edge[size + 1][size];
    this.edges_d_se = new Edge[size][size];
    this.edges_d_sw = new Edge[size][size];
    
    for (int x = 0; x < size; x++)
    for (int y = 0; y < size; y++)
    {
      this.edges_h[x][y] = new Edge(Math.random() < 0.3);
      this.edges_v[x][y] = new Edge(Math.random() < 0.3);
      this.edges_d_se[x][y] = new Edge(Math.random() < 0.2);
      this.edges_d_sw[x][y] = new Edge(Math.random() < 0.2);
    }
    
    for (int x = 0; x < size; x++)
      this.edges_h[x][size] = new Edge(false);
    for (int y = 0; y < size; y++)
      this.edges_v[size][y] = new Edge(false);
  }
  
  void lightLine(int x0, int y0, int x1, int y1)
  {
    stroke(64);
    line(x0, y0, x1, y1);
  }

  void darkLine(int x0, int y0, int x1, int y1)
  {
    stroke(255);
    line(x0, y0, x1, y1);
  }

  void toggleLine(int x0, int y0, int x1, int y1)
  {
    // work out which array we need to modify
    if (x0 == x1)
    {
      this.edges_v[x0][min(y0, y1)].toggle();
    }
    else if (y0 == y1)
    {
      this.edges_h[min(x0, x1)][y0].toggle();
    }
    else if ((x1 - x0) == (y1 - y0))
    {
      this.edges_d_se[min(x0, x1)][min(y0, y1)].toggle();
    }
    else
    {
      this.edges_d_sw[min(x0, x1)][min(y0, y1)].toggle();
    }
  }
  
  void drawSubgrid(int ox, int oy)
  {
    if (ox >= divisions || oy >= divisions)
    {
      println("BAD CELL CO-ORDINATES!");
      exit();
    }
    
    int cells_per_division = size / divisions;
    
    stroke(255, 0, 0);
    strokeWeight(0.05);
    rect(0.5 * cells_per_division, 0.5 * cells_per_division, cells_per_division, cells_per_division);

    stroke(0);
    strokeWeight(0.02);    
    
    for (int x = 0; x < 2 * cells_per_division; x++)
    for (int y = 0; y < 2 * cells_per_division; y++)
    {
      int ix = ox - (cells_per_division / 2) + (x * cells_per_division);
      if (ix >= size) ix -= size;
      if (ix < 0) ix += size;

      int iy = oy - (cells_per_division / 2) + (y * cells_per_division);
      if (iy >= size) iy -= size;
      if (iy < 0) iy += size;
      
      // draw horiz
      this.lightLine(x, y, x + 1, y);
      if (this.edges_h[ix][iy].on) this.darkLine(x, y, x + 1, y);
      
      // draw vert
      this.lightLine(x, y, x, y + 1);
      if (this.edges_v[ix][iy].on) this.darkLine(x, y, x, y + 1);
      
      // draw diag se
      this.lightLine(x, y, x + 1, y + 1);
      if (this.edges_d_se[ix][iy].on) this.darkLine(x, y, x + 1, y + 1);
      
      // draw diag sw
      this.lightLine(x, y + 1, x + 1, y);
      if (this.edges_d_sw[ix][iy].on) this.darkLine(x, y + 1, x + 1, y);
    }
  }

  void draw()
  {
    stroke(0);
    strokeWeight(0.02);
    
    for (int x = 0; x < size; x++)
    for (int y = 0; y < size; y++)
    {
      // draw horiz
      this.lightLine(x, y, x + 1, y);
      if (this.edges_h[x][y].on) this.darkLine(x, y, x + 1, y);
      
      // draw vert
      this.lightLine(x, y, x, y + 1);
      if (this.edges_v[x][y].on) this.darkLine(x, y, x, y + 1);
      
      // draw diag se
      this.lightLine(x, y, x + 1, y + 1);
      if (this.edges_d_se[x][y].on) this.darkLine(x, y, x + 1, y + 1);
      
      // draw diag sw
      this.lightLine(x, y + 1, x + 1, y);
      if (this.edges_d_sw[x][y].on) this.darkLine(x, y + 1, x + 1, y);
    }
  }
  
  String [] serialize()
  {
    String data[] = new String[4];

    data[0] = "";
    for (int x = 0; x < size; x++)
    for (int y = 0; y < size + 1; y++)
      data[0] = data[0] + (this.edges_h[x][y].on ? 1 : 0);

    data[1] = "";
    for (int x = 0; x < size + 1; x++)
    for (int y = 0; y < size; y++)
      data[1] = data[1] + (this.edges_v[x][y].on ? 1 : 0);

    data[2] = "";
    for (int x = 0; x < size; x++)
    for (int y = 0; y < size; y++)
      data[2] = data[2] + (this.edges_d_se[x][y].on ? 1 : 0);

    data[3] = "";
    for (int x = 0; x < size; x++)
    for (int y = 0; y < size; y++)
      data[3] = data[3] + (this.edges_d_sw[x][y].on ? 1 : 0);
      
    return data;
  }
}

class Edge
{
  boolean on = false;
  
  Edge(boolean on)
  {
    this.on = on;
  }
  
  void toggle()
  {
    on = !on;
  }
}


PVector origin;
PVector persp;
Grid grid;

int CELL_WIDTH = 30;
int CELL_COUNT = 16;
int CELL_DIVISIONS = 8;

void setup()
{
  size(CELL_WIDTH * CELL_COUNT, CELL_WIDTH * CELL_COUNT);
  smooth();

  grid = new Grid(CELL_COUNT, CELL_DIVISIONS);
  origin = new PVector(-1, -1);
  persp = new PVector(0, 0);
}

void draw()
{
  background(0);
  noFill();  
  scale(CELL_WIDTH, CELL_WIDTH);
  // grid.drawSubgrid(int(persp.x), int(persp.y));
  grid.draw();
}

void mouseDragged()
{
  float normX = (float) mouseX / CELL_WIDTH;
  float normY = (float) mouseY / CELL_WIDTH;
  float distX = abs(round(normX) - normX);
  float distY = abs(round(normY) - normY);
  float nearestX = round(normX);
  float nearestY = round(normY);

  if (dist(distX, distY, 0, 0) < 0.5)
  {
    stroke(0);
    strokeWeight(1.5);
    if (origin.x == -1)
    {
      // don't have a current drag origin - set.
      origin.x = nearestX;
      origin.y = nearestY;      
    }
    else if ((origin.x != -1) && ((origin.x != nearestX) || (origin.y != nearestY)))
    {
      // new line to add
      grid.toggleLine((int) origin.x, (int) origin.y, (int) nearestX, (int) nearestY);
      origin.x = nearestX;
      origin.y = nearestY;
    }
  }
}

void mouseReleased()
{
  origin.x = -1;
  origin.y = -1;
}

void keyPressed()
{
  if (key == 's')
  {
    String serial[] = grid.serialize();
    for (int i = 0; i < serial.length; i++)
      println(serial[i]);
  }
  switch (keyCode)
  {
    case RIGHT: persp.x += 1; break;
    case LEFT: persp.x -= 1; break;
    case UP: persp.y -= 1; break;
    case DOWN: persp.y += 1; break;
  }
}

